// input types.
Type Variable, Object, Field, Statement.

// input facts.
Relation New(stm: Statement, lhs: Variable, obj: Object).
Relation Assign(stm: Statement, lhs: Variable, rhs: Variable).
Relation Load(stm: Statement, lhs: Variable, base: Variable, field: Field).
Relation Store(stm: Statement, base: Variable, field: Field, rhs: Variable).

// the succesor relation.
Relation Successor(s1: Statement, s2: Statement).

// flow insensitive: variable & heap abstraction.
Relation VarPointsTo#(variable: Variable, Object).
Relation HeapPointsTo#(base: Object, field: Field, Object).

// *** flow insenstive ***
Constraint VarPointsTo#(var, obj) :-
    New(var, obj).

Constraint VarPointsTo#(var1, value) :-
    Assign(var1, var2),
    VarPointsTo#(var2, value).

Constraint VarPointsTo#(var1, value) :-
    Load(var1, var2, field),
    VarPointsTo#(var2, base),
    HeapPointsTo#(base, field, value).

Constraint HeapPointsTo#(base, field, value) :-
    Store(var1, f, var2),
    VarPointsTo#(var1, base),
    VarPointsTo#(var2, value).

// lattice of singletons.
Lattice Singletons = Top | Bot | One(Object).

// flow sensitive: variable & heap abstraction.
Lattice VarPointsTo(stm: Statement, variable: Variable, Singletons).
Lattice HeapPointsTo(stm: Statement, base: Object, field: Field, Singletons).

// *** flow sensitive ***
Constraint VarPointsTo(s2, var, value) :-
    New(s1, var, obj),
    Successor(s1, s2),
    value <- One(obj).

Constraint VarPointsTo(s2, var1, value) :-
    Assign(s1, var1, var2),
    VarPointsTo(s1, var2, value),
    Successor(s1, s2).

Constraint VarPointsTo(s2, var1, value) :-
    Load(s1, var1, var2, field),
    VarPointsTo#(s1, var2, base), // notice the use of VarPointsTo#
    HeapPointsTo(s1, base, field, value),
    Successor(s1, s2).

Constraint HeapPointsTo(s2, base, field, value) :-
    Store(s1, var1, f, var2),
    VarPointsTo(s1, var1, base), // notice the use VarPointsTo#
    VarPointsTo(s1, var2, value),
    Successor(s1, s2).
