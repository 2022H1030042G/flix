package ca.uwaterloo.flix.language.phase

import org.objectweb.asm
import org.objectweb.asm.{ClassWriter, Label}
import org.objectweb.asm.Opcodes._

/**
  * Created by ramin on 2017-05-22.
  *
  * Generates classes and interfaces which will represent enums
  */
object Enumgen {
  import CodegenHelper._

  /**
    * Generates an interface for TagInterface which includes one method which
    * returns the name of the enum case which implements this interface
    * @param name name of the class
    * @return byte code representation of the class
    */
  def compileTagInterface(name: List[String]) : Array[Byte] = {
    val visitor = new ClassWriter(0)

    visitor.visit(V1_8, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, decorate(name), null,
      asm.Type.getInternalName(Constants.objectClass), null)

    val getTagMethod = visitor.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getTag",
      s"()${asm.Type.getDescriptor(Constants.stringClass)}", null, null)
    getTagMethod.visitEnd()

    visitor.visitEnd()
    visitor.toByteArray
  }

  /**
    * Generates an interface for each enum.
    * Each case of the enum implements this interface. This interface extends `TagInterface`.
    * @param name name of the class
    * @param tagInterface the tagInterface
    * @return byte code representation of the class
    */
  def compileEnumInterface(name: List[String], tagInterface: Class[_]): Array[Byte] = {
    val visitor = new ClassWriter(0)

    visitor.visit(V1_8, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, decorate(name), null,
      asm.Type.getInternalName(Constants.objectClass), Array(asm.Type.getInternalName(tagInterface)))

    visitor.visitEnd()
    visitor.toByteArray
  }

  /**
    * Generates the class for each enum case.
    * Each class implements the interface of enum.
    * @param name name of the class
    * @param enumInterface interfaces for enums
    * @param tpe type of the `value` field of the class
    * @return byte code representation of the class
    */
  def compileEnumClass(name: List[String], enumInterface: Class[_], tpe: String): Array[Byte] = {
    // Initialize the class writer.
    val visitor = new ClassWriter(ClassWriter.COMPUTE_FRAMES)

    // Initialize the visitor to create a class.
    visitor.visit(V1_8, ACC_PUBLIC, decorate(name), null, asm.Type.getInternalName(Constants.objectClass),
      Array(asm.Type.getInternalName(enumInterface)))

    // Generate tag and value fields
    compileEnumField(visitor, "value", tpe)
    compileEnumField(visitor, "tag", asm.Type.getDescriptor(Constants.stringClass))

    // Generate the constructor of the class
    compileEnumConstructor(visitor, name, tpe)

    // Generate the `getValue` method
    compileGetFieldMethod(visitor, name, tpe, "value", "getValue")
    // Generate the `getTag` method
    compileGetFieldMethod(visitor, name, asm.Type.getDescriptor(Constants.stringClass), "tag", "getTag")

    // Generate `hashCode` method
    compileHashCodeMethod(visitor, name, tpe)

    // Generate `toString` method
    compileToStringMethod(visitor, name, tpe)

    // Generate `equals` method
    compileEqualsMethod(visitor, name)

    visitor.visitEnd()
    visitor.toByteArray
  }

  /**
    * Creates a field of name `name` with type `tpe` on the class generated by `visitor`
    * @param visitor class visitor
    * @param name name of the field
    * @param tpe type of the field
    */
  private def compileEnumField(visitor: ClassWriter, name: String, tpe: String) = {
    val field = visitor.visitField(ACC_PUBLIC, name, tpe, null, null)
    field.visitEnd()
  }

  /**
    * Creates constructor of the enum case class which is named `name`.
    * The type of the field of the case is give by `tpe`
    * @param visitor class visitor
    * @param name name of the class
    * @param tpe type of the `value` field of the class
    */
  private def compileEnumConstructor(visitor: ClassWriter, name: List[String], tpe: String) = {
    val constructor = visitor.visitMethod(ACC_PUBLIC, "<init>", s"($tpe)V", null, null)
    val clazz = Constants.objectClass
    val ctor = clazz.getConstructor()

    constructor.visitCode()
    constructor.visitVarInsn(ALOAD, 0)

    // Call the super (java.lang.Object) constructor
    constructor.visitMethodInsn(INVOKESPECIAL, asm.Type.getInternalName(clazz), "<init>",
      asm.Type.getConstructorDescriptor(ctor), false)

    // Put the object given to the construct on the `value` field
    constructor.visitVarInsn(ALOAD, 0)
    constructor.visitVarInsn(ALOAD, 1)
    constructor.visitFieldInsn(PUTFIELD, decorate(name), "value", tpe)


    // Put the name of the tag on the `tag` field
    constructor.visitVarInsn(ALOAD, 0)
    constructor.visitLdcInsn(name.last)
    constructor.visitFieldInsn(PUTFIELD, decorate(name), "tag", asm.Type.getDescriptor(Constants.stringClass))

    // Return
    constructor.visitInsn(RETURN)
    constructor.visitMaxs(65535, 65535)
    constructor.visitEnd()
  }

  /**
    * Generate the `methodName` method for fetching the `fieldName` field of the class.
    * `name` is name of the class and `tpe` is type of the `fieldName` field.
    * @param visitor class visitor
    * @param name name of the class
    * @param tpe type of the `value` field of the class
    * @param fieldName name of the field
    * @param methodName method name of getter of `fieldName`
    */
  private def compileGetFieldMethod(visitor: ClassWriter, name: List[String], tpe: String, fieldName: String, methodName: String) = {
    val method = visitor.visitMethod(ACC_PUBLIC + ACC_FINAL, methodName, s"()$tpe", null, null)

    method.visitCode()
    method.visitVarInsn(ALOAD, 0)
    method.visitFieldInsn(GETFIELD, decorate(name), fieldName, tpe)
    method.visitInsn(ARETURN)
    method.visitMaxs(1, 1)
    method.visitEnd()
  }

  /**
    * Generate the `hashCode` for the class.
    * The hashCode in this case is `7 * name.hashCode() + 11 * this.value.hashCode()`
    * 'tpe' is type of `value` field.
    * @param visitor class visitor
    * @param name name of the class
    * @param tpe type of the `value` field of the class
    */
  private def compileHashCodeMethod(visitor: ClassWriter, name: List[String], tpe: String) = {
    val clazz = Constants.objectClass
    val objectMethod = clazz.getMethod("hashCode")
    val method = visitor.visitMethod(ACC_PUBLIC, "hashCode", "()I", null, null)

    method.visitCode()
    method.visitLdcInsn(7)
    method.visitLdcInsn(name.hashCode())
    method.visitInsn(IMUL)
    method.visitLdcInsn(11)
    method.visitVarInsn(ALOAD, 0)
    method.visitFieldInsn(GETFIELD, decorate(name), "value", tpe)
    method.visitMethodInsn(INVOKEVIRTUAL, asm.Type.getInternalName(clazz), objectMethod.getName,
      asm.Type.getMethodDescriptor(objectMethod), false)
    method.visitInsn(IMUL)
    method.visitInsn(IADD)

    method.visitInsn(IRETURN)
    method.visitMaxs(1, 1)
    method.visitEnd()
  }

  /**
    * Generate the `toString` method for the class. The method returns `tag(value.toString())`.
    * @param visitor class visitor
    * @param name name of the class
    * @param tpe type of the `value` field of the class
    */
  private def compileToStringMethod(visitor: ClassWriter, name: List[String], tpe: String) = {
    val objectInternalName = asm.Type.getInternalName(Constants.objectClass)
    val stringInternalName = asm.Type.getInternalName(Constants.stringClass)
    val objectToStringMethod = Constants.objectClass.getMethod("toString")
    val stringConcatMethod = Constants.stringClass.getMethod("concat", Constants.stringClass)

    val method = visitor.visitMethod(ACC_PUBLIC, "toString", s"()${asm.Type.getDescriptor(Constants.stringClass)}", null, null)

    method.visitCode()
    method.visitLdcInsn(name.last.concat("("))
    method.visitVarInsn(ALOAD, 0)
    method.visitFieldInsn(GETFIELD, decorate(name), "value", tpe)
    method.visitMethodInsn(INVOKEVIRTUAL, objectInternalName, objectToStringMethod.getName,
      asm.Type.getMethodDescriptor(objectToStringMethod), false)
    method.visitLdcInsn(")")
    // We do this twice since there is 3 strings on the stack that we want to concat them together
    for(_ <- 0 until 2) {
      method.visitMethodInsn(INVOKEVIRTUAL, stringInternalName, stringConcatMethod.getName,
        asm.Type.getMethodDescriptor(stringConcatMethod), false)
    }

    method.visitInsn(ARETURN)
    method.visitMaxs(1, 10)
    method.visitEnd()
  }

  /**
    * Generate the `equals` method for the class.
    * @param visitor class visitor
    * @param name name of the class
    */
  private def compileEqualsMethod(visitor: ClassWriter, name: List[String]) = {
    val clazz = Constants.objectClass
    val objectEqualsMethod = clazz.getMethod("equals", clazz)
    val neq = new Label() //label for when the object is not instanceof tag case

    val method = visitor.visitMethod(ACC_PUBLIC, "equals", s"(${asm.Type.getDescriptor(clazz)})Z", null, null)
    method.visitCode()
    method.visitVarInsn(ALOAD, 1)
    method.visitTypeInsn(INSTANCEOF, decorate(name))
    method.visitJumpInsn(IFEQ, neq)
    method.visitVarInsn(ALOAD, 0)
    method.visitFieldInsn(GETFIELD, decorate(name), "value", asm.Type.getDescriptor(clazz))
    method.visitVarInsn(ALOAD, 1)
    method.visitTypeInsn(CHECKCAST, decorate(name))
    method.visitFieldInsn(GETFIELD, decorate(name), "value", asm.Type.getDescriptor(clazz))
    method.visitMethodInsn(INVOKEVIRTUAL, asm.Type.getInternalName(clazz), objectEqualsMethod.getName,
      asm.Type.getMethodDescriptor(objectEqualsMethod), false)
    method.visitInsn(IRETURN)
    method.visitLabel(neq)
    method.visitInsn(ICONST_0)
    method.visitInsn(IRETURN)
    method.visitMaxs(10, 10)

    method.visitEnd()
  }
}
