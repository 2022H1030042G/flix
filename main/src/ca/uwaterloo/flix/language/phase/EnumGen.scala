package ca.uwaterloo.flix.language.phase

import org.objectweb.asm
import org.objectweb.asm.{ClassWriter, Label}
import org.objectweb.asm.Opcodes._
import ca.uwaterloo.flix.language.ast.{Type, _}
import ca.uwaterloo.flix.util.InternalCompilerException

/**
  * Created by ramin on 2017-05-22.
  *
  * Generates classes and interfaces which will represent enums
  */
object Enumgen {
  import CodegenHelper._

  /**
    * Generates an interface for TagInterface which includes one method which
    * returns the name of the enum case which implements this interface
    * @param name name of the class
    * @return byte code representation of the class
    */
  def compileTagInterface(name: List[String]) : Array[Byte] = {
    val visitor = new ClassWriter(0)

    visitor.visit(V1_8, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, decorate(name), null,
      asm.Type.getInternalName(Constants.objectClass), null)

    val getTagMethod = visitor.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "getTag",
      s"()${asm.Type.getDescriptor(Constants.stringClass)}", null, null)
    getTagMethod.visitEnd()

    visitor.visitEnd()
    visitor.toByteArray
  }

  /**
    * Generates an interface for each enum.
    * Each case of the enum implements this interface. This interface extends `TagInterface`.
    * @param name name of the class
    * @param tagInterface the tagInterface
    * @return byte code representation of the class
    */
  def compileEnumInterface(name: List[String], tagInterface: Class[_]): Array[Byte] = {
    val visitor = new ClassWriter(0)

    visitor.visit(V1_8, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, decorate(name), null,
      asm.Type.getInternalName(Constants.objectClass), Array(asm.Type.getInternalName(tagInterface)))

    visitor.visitEnd()
    visitor.toByteArray
  }

  /**
    * Generates the class for each enum case.
    * Each class implements the interface of enum.
    * @param name name of the class
    * @param enumInterface interfaces for enums
    * @param tpe descriptor of the `value` field of the class
    * @param fType Type of the `value` field
    * @return byte code representation of the class
    */
  def compileEnumClass(name: List[String], enumInterface: Class[_], tpe: String, fType: Type): Array[Byte] = {
    // Initialize the class writer.
    val visitor = new ClassWriter(ClassWriter.COMPUTE_FRAMES)

    // Initialize the visitor to create a class.
    visitor.visit(V1_8, ACC_PUBLIC, decorate(name), null, asm.Type.getInternalName(Constants.objectClass),
      Array(asm.Type.getInternalName(enumInterface)))

    // Generate tag and value fields
    compileEnumField(visitor, "value", tpe)
    compileEnumField(visitor, "tag", asm.Type.getDescriptor(Constants.stringClass))

    // Generate the constructor of the class
    compileEnumConstructor(visitor, name, tpe, fType)

    // Generate the `getValue` method
    // Picking the right opcode for return
    val retCode = fType match {
      case Type.Var(id, kind) =>  throw InternalCompilerException(s"Non-monomorphed type variable '$id in type '$tpe'.")
      case Type.Bool | Type.Char | Type.Int8 | Type.Int16 | Type.Int32 => IRETURN
      case Type.Int64 => LRETURN
      case Type.Float32 => FRETURN
      case Type.Float64 => DRETURN
      case _ => ARETURN
    }
    compileGetFieldMethod(visitor, name, tpe, "value", "getValue", retCode)
    // Generate the `getTag` method
    compileGetFieldMethod(visitor, name, asm.Type.getDescriptor(Constants.stringClass), "tag", "getTag", ARETURN)

    // Generate `hashCode` method
    compileHashCodeMethod(visitor, name, tpe, fType)

    // Generate `toString` method
    compileToStringMethod(visitor, name, tpe, fType)

    // Generate `equals` method
    compileEqualsMethod(visitor, name, tpe, fType)

    visitor.visitEnd()
    visitor.toByteArray
  }

  /**
    * Creates a field of name `name` with type `tpe` on the class generated by `visitor`
    * @param visitor class visitor
    * @param name name of the field
    * @param tpe descriptor of `value` field
    */
  private def compileEnumField(visitor: ClassWriter, name: String, tpe: String) = {
    val field = visitor.visitField(ACC_PUBLIC, name, tpe, null, null)
    field.visitEnd()
  }

  /**
    * Creates constructor of the enum case class which is named `name`.
    * The type of the field of the case is give by `tpe`
    * @param visitor class visitor
    * @param name name of the class
    * @param tpe descriptor of the `value` field
    * @param fType type of the `value` field
    */
  private def compileEnumConstructor(visitor: ClassWriter, name: List[String], tpe: String, fType: Type) = {
    val constructor = visitor.visitMethod(ACC_PUBLIC, "<init>", s"($tpe)V", null, null)
    val clazz = Constants.objectClass
    val ctor = clazz.getConstructor()

    constructor.visitCode()
    constructor.visitVarInsn(ALOAD, 0)

    // Call the super (java.lang.Object) constructor
    constructor.visitMethodInsn(INVOKESPECIAL, asm.Type.getInternalName(clazz), "<init>",
      asm.Type.getConstructorDescriptor(ctor), false)

    // Load instruction for type of `value`
    val iLoad : Int = fType match {
      case Type.Var(id, kind) =>  throw InternalCompilerException(s"Non-monomorphed type variable '$id in type '$tpe'.")
      case Type.Bool | Type.Char | Type.Int8 | Type.Int16 | Type.Int32 => ILOAD
      case Type.Int64 => LLOAD
      case Type.Float32 => FLOAD
      case Type.Float64 => DLOAD
      case _ => ALOAD
    }

    // Put the object given to the construct on the `value` field
    constructor.visitVarInsn(ALOAD, 0)
    constructor.visitVarInsn(iLoad, 1)
    constructor.visitFieldInsn(PUTFIELD, decorate(name), "value", tpe)


    // Put the name of the tag on the `tag` field
    constructor.visitVarInsn(ALOAD, 0)
    constructor.visitLdcInsn(name.last)
    constructor.visitFieldInsn(PUTFIELD, decorate(name), "tag", asm.Type.getDescriptor(Constants.stringClass))

    // Return
    constructor.visitInsn(RETURN)
    constructor.visitMaxs(65535, 65535)
    constructor.visitEnd()
  }

  /**
    * Generate the `methodName` method for fetching the `fieldName` field of the class.
    * `name` is name of the class and `tpe` is type of the `fieldName` field.
    * @param visitor class visitor
    * @param name name of the class
    * @param tpe type of the `value` field of the class
    * @param fieldName name of the field
    * @param methodName method name of getter of `fieldName`
    * @param iReturn opcode for returning the value of the field
    */
  private def compileGetFieldMethod(visitor: ClassWriter, name: List[String], tpe: String, fieldName: String,
                                    methodName: String, iReturn: Int) = {
    val method = visitor.visitMethod(ACC_PUBLIC + ACC_FINAL, methodName, s"()$tpe", null, null)

    method.visitCode()
    method.visitVarInsn(ALOAD, 0)
    method.visitFieldInsn(GETFIELD, decorate(name), fieldName, tpe)
    method.visitInsn(iReturn)
    method.visitMaxs(1, 1)
    method.visitEnd()
  }

  /**
    * Generate the `hashCode` for the class.
    * The hashCode in this case is `7 * name.hashCode() + 11 * this.value.hashCode()`
    * 'tpe' is type of `value` field.
    * @param visitor class visitor
    * @param name name of the class
    * @param tpe descriptor of the `value` field of the class
    * @param fType type of the underlying `value`
    */
  private def compileHashCodeMethod(visitor: ClassWriter, name: List[String], tpe: String, fType: Type) = {
    val clazz = Constants.objectClass
    val objectMethod = clazz.getMethod("hashCode")
    val method = visitor.visitMethod(ACC_PUBLIC, "hashCode", "()I", null, null)

    method.visitCode()
    method.visitLdcInsn(7)
    method.visitLdcInsn(name.hashCode())
    method.visitInsn(IMUL)
    method.visitLdcInsn(11)
    method.visitVarInsn(ALOAD, 0)
    method.visitFieldInsn(GETFIELD, decorate(name), "value", tpe)

    /*
     * If the field is of type Object, we get the hashCode of the object
     * Otherwise, we convert the type to integer and use in hash code computation
     */
    fType match {
      case Type.Var(id, kind) =>  throw InternalCompilerException(s"Non-monomorphed type variable '$id in type '$tpe'.")
      case Type.Bool | Type.Char | Type.Int8 | Type.Int16 | Type.Int32 =>
      case Type.Int64 => method.visitInsn(L2I)
      case Type.Float32 => method.visitInsn(F2I)
      case Type.Float64 => method.visitInsn(D2I)
      case _ => method.visitMethodInsn(INVOKEVIRTUAL, asm.Type.getInternalName(clazz), objectMethod.getName,
        asm.Type.getMethodDescriptor(objectMethod), false)
    }

    method.visitInsn(IMUL)
    method.visitInsn(IADD)

    method.visitInsn(IRETURN)
    method.visitMaxs(1, 1)
    method.visitEnd()
  }

  /**
    * Generate the `toString` method for the class. The method returns `tag(value.toString())`.
    * @param visitor class visitor
    * @param name name of the class
    * @param tpe descriptor of the `value` field of the class
    * @param fType type of the `value` field
    */
  private def compileToStringMethod(visitor: ClassWriter, name: List[String], tpe: String, fType: Type) = {
    val objectInternalName = asm.Type.getInternalName(Constants.objectClass)
    val stringInternalName = asm.Type.getInternalName(Constants.stringClass)
    val stringConcatMethod = Constants.stringClass.getMethod("concat", Constants.stringClass)

    val method = visitor.visitMethod(ACC_PUBLIC, "toString", s"()${asm.Type.getDescriptor(Constants.stringClass)}", null, null)

    method.visitCode()
    method.visitLdcInsn(name.last.concat("("))
    method.visitVarInsn(ALOAD, 0)
    method.visitFieldInsn(GETFIELD, decorate(name), "value", tpe)

    /*
     * Converting `value` to String.
     * If it's an object, we will call `toString` on the object.
     * Otherwise, we use `valueOf` static method on String with the appropriate type.
     */
    fType match {
      case Type.Var(id, kind) =>  throw InternalCompilerException(s"Non-monomorphed type variable '$id in type '$tpe'.")
      case Type.Bool =>
        val boolToStringMethod = Constants.stringClass.getMethod("valueOf", classOf[Boolean])
        method.visitMethodInsn(INVOKESTATIC, stringInternalName, boolToStringMethod.getName,
          asm.Type.getMethodDescriptor(boolToStringMethod), false)
      case Type.Char =>
        val charToStringMethod = Constants.stringClass.getMethod("valueOf", classOf[Char])
        method.visitMethodInsn(INVOKESTATIC, stringInternalName, charToStringMethod.getName,
          asm.Type.getMethodDescriptor(charToStringMethod), false)
      case Type.Int8 | Type.Int16 | Type.Int32 =>
        val intToStringMethod = Constants.stringClass.getMethod("valueOf", classOf[Int])
        method.visitMethodInsn(INVOKESTATIC, stringInternalName, intToStringMethod.getName,
          asm.Type.getMethodDescriptor(intToStringMethod), false)
      case Type.Int64 =>
        val longToStringMethod = Constants.stringClass.getMethod("valueOf", classOf[Long])
        method.visitMethodInsn(INVOKESTATIC, stringInternalName, longToStringMethod.getName,
          asm.Type.getMethodDescriptor(longToStringMethod), false)
      case Type.Float32 =>
        val floatToStringMethod = Constants.stringClass.getMethod("valueOf", classOf[Float])
        method.visitMethodInsn(INVOKESTATIC, stringInternalName, floatToStringMethod.getName,
          asm.Type.getMethodDescriptor(floatToStringMethod), false)
      case Type.Float64 =>
        val doubleToStringMethod = Constants.stringClass.getMethod("valueOf", classOf[Double])
        method.visitMethodInsn(INVOKESTATIC, stringInternalName, doubleToStringMethod.getName,
          asm.Type.getMethodDescriptor(doubleToStringMethod), false)
      case _ =>
        val objectToStringMethod = Constants.objectClass.getMethod("toString")
        method.visitMethodInsn(INVOKEVIRTUAL, objectInternalName, objectToStringMethod.getName,
          asm.Type.getMethodDescriptor(objectToStringMethod), false)
    }

    method.visitLdcInsn(")")


    // We do this twice since there is 3 strings on the stack that we want to concat them together
    for(_ <- 0 until 2) {
      method.visitMethodInsn(INVOKEVIRTUAL, stringInternalName, stringConcatMethod.getName,
        asm.Type.getMethodDescriptor(stringConcatMethod), false)
    }

    method.visitInsn(ARETURN)
    method.visitMaxs(1, 10)
    method.visitEnd()
  }

  /**
    * Generate the `equals` method for the class.
    * @param visitor class visitor
    * @param name name of the class
    * @param tpe descriptor of the `value` field
    * @param fType Type of the `value` field
    */
  private def compileEqualsMethod(visitor: ClassWriter, name: List[String], tpe: String, fType: Type) = {
    val clazz = Constants.objectClass
    val objectEqualsMethod = clazz.getMethod("equals", clazz)
    val neq = new Label() //label for when the object is not instanceof tag case

    val method = visitor.visitMethod(ACC_PUBLIC, "equals", s"(${asm.Type.getDescriptor(clazz)})Z", null, null)
    method.visitCode()
    method.visitVarInsn(ALOAD, 1)
    method.visitTypeInsn(INSTANCEOF, decorate(name))
    method.visitJumpInsn(IFEQ, neq)
    method.visitVarInsn(ALOAD, 0)
    method.visitFieldInsn(GETFIELD, decorate(name), "value", tpe)
    method.visitVarInsn(ALOAD, 1)
    method.visitTypeInsn(CHECKCAST, decorate(name))
    method.visitFieldInsn(GETFIELD, decorate(name), "value", tpe)

    // This will pick the appropriate comparison for the type of the `value`
    fType match {
      case Type.Var(id, kind) =>  throw InternalCompilerException(s"Non-monomorphed type variable '$id in type '$fType'.")
      case Type.Bool | Type.Char | Type.Int8 | Type.Int16 | Type.Int32 =>
        method.visitJumpInsn(IF_ICMPNE, neq)
        method.visitInsn(ICONST_1)
      case Type.Int64 =>
        method.visitInsn(LCMP)
        method.visitJumpInsn(IFNE, neq)
        method.visitInsn(ICONST_1)
      case Type.Float32 =>
        method.visitInsn(FCMPG)
        method.visitJumpInsn(IFNE, neq)
        method.visitInsn(ICONST_1)
      case Type.Float64 =>
        method.visitInsn(DCMPG)
        method.visitJumpInsn(IFNE, neq)
        method.visitInsn(ICONST_1)
      case _ =>
        method.visitMethodInsn(INVOKEVIRTUAL, asm.Type.getInternalName(clazz), objectEqualsMethod.getName,
          asm.Type.getMethodDescriptor(objectEqualsMethod), false)
    }

    method.visitInsn(IRETURN)
    method.visitLabel(neq)
    method.visitInsn(ICONST_0)
    method.visitInsn(IRETURN)
    method.visitMaxs(10, 10)

    method.visitEnd()
  }
}
